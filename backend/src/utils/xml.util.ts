// XML utilities for EAD (Encoded Archival Description) export
// EAD is an international standard for archival finding aids

export interface EADDocument {
  id: string
  title: string
  description?: string
  creator?: string
  date?: string
  extent?: string
  language?: string
  repository?: string
  collection?: string
  accessRestrictions?: string
  useRestrictions?: string
  relatedMaterials?: string
  subjects?: string[]
  files?: EADFile[]
}

export interface EADFile {
  id: string
  title: string
  filename: string
  format: string
  size: string
  checksum?: string
  href?: string
}

export interface EADCollection {
  id: string
  title: string
  description: string
  repository: {
    name: string
    address: string
    country: string
  }
  creator: string
  dates: {
    creation: string
    bulk?: string
  }
  extent: string
  language: string
  abstract: string
  accessRestrictions?: string
  useRestrictions?: string
  documents: EADDocument[]
}

/**
 * Generate EAD XML for a single document
 */
export function generateDocumentEAD(document: EADDocument): string {
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<ead xmlns="urn:isbn:1-931666-22-9" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="urn:isbn:1-931666-22-9 http://www.loc.gov/ead/ead.xsd">
  
  <eadheader>
    <eadid countrycode="RO" mainagencycode="RO-OpenArchive">${escapeXml(document.id)}</eadid>
    <filedesc>
      <titlestmt>
        <titleproper>${escapeXml(document.title)}</titleproper>
        <author>OpenArchive System</author>
      </titlestmt>
      <publicationstmt>
        <publisher>Guvernul României - Arhivele Naționale</publisher>
        <date>${new Date().getFullYear()}</date>
      </publicationstmt>
    </filedesc>
    <profiledesc>
      <creation>Generated by OpenArchive System <date>${new Date().toISOString()}</date></creation>
      <langusage>
        <language langcode="${document.language || 'rum'}">Romanian</language>
      </langusage>
    </profiledesc>
  </eadheader>

  <archdesc level="item">
    <did>
      <unittitle>${escapeXml(document.title)}</unittitle>
      <unitid>${escapeXml(document.id)}</unitid>
      ${document.date ? `<unitdate>${escapeXml(document.date)}</unitdate>` : ''}
      ${document.extent ? `<physdesc><extent>${escapeXml(document.extent)}</extent></physdesc>` : ''}
      ${document.repository ? `<repository><corpname>${escapeXml(document.repository)}</corpname></repository>` : ''}
      ${document.creator ? `<origination><persname>${escapeXml(document.creator)}</persname></origination>` : ''}
      ${document.language ? `<langmaterial><language langcode="${document.language}">${getLanguageName(document.language)}</language></langmaterial>` : ''}
    </did>

    ${document.description ? `<scopecontent><p>${escapeXml(document.description)}</p></scopecontent>` : ''}
    
    ${document.accessRestrictions ? `<accessrestrict><p>${escapeXml(document.accessRestrictions)}</p></accessrestrict>` : ''}
    
    ${document.useRestrictions ? `<userestrict><p>${escapeXml(document.useRestrictions)}</p></userestrict>` : ''}
    
    ${document.relatedMaterials ? `<relatedmaterial><p>${escapeXml(document.relatedMaterials)}</p></relatedmaterial>` : ''}
    
    ${generateSubjectSection(document.subjects)}
    
    ${generateDigitalObjectsSection(document.files)}
  </archdesc>
</ead>`

  return formatXml(xml)
}

/**
 * Generate EAD XML for a collection of documents
 */
export function generateCollectionEAD(collection: EADCollection): string {
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<ead xmlns="urn:isbn:1-931666-22-9" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="urn:isbn:1-931666-22-9 http://www.loc.gov/ead/ead.xsd">
  
  <eadheader>
    <eadid countrycode="RO" mainagencycode="RO-OpenArchive">${escapeXml(collection.id)}</eadid>
    <filedesc>
      <titlestmt>
        <titleproper>${escapeXml(collection.title)}</titleproper>
        <author>OpenArchive System</author>
      </titlestmt>
      <publicationstmt>
        <publisher>${escapeXml(collection.repository.name)}</publisher>
        <address>
          <addressline>${escapeXml(collection.repository.address)}</addressline>
          <addressline>${escapeXml(collection.repository.country)}</addressline>
        </address>
        <date>${new Date().getFullYear()}</date>
      </publicationstmt>
    </filedesc>
    <profiledesc>
      <creation>Generated by OpenArchive System <date>${new Date().toISOString()}</date></creation>
      <langusage>
        <language langcode="${collection.language}">Romanian</language>
      </langusage>
    </profiledesc>
  </eadheader>

  <archdesc level="collection">
    <did>
      <unittitle>${escapeXml(collection.title)}</unittitle>
      <unitid>${escapeXml(collection.id)}</unitid>
      <unitdate type="inclusive">${escapeXml(collection.dates.creation)}</unitdate>
      ${collection.dates.bulk ? `<unitdate type="bulk">${escapeXml(collection.dates.bulk)}</unitdate>` : ''}
      <physdesc><extent>${escapeXml(collection.extent)}</extent></physdesc>
      <repository>
        <corpname>${escapeXml(collection.repository.name)}</corpname>
        <address>
          <addressline>${escapeXml(collection.repository.address)}</addressline>
        </address>
      </repository>
      <origination>
        <persname>${escapeXml(collection.creator)}</persname>
      </origination>
      <langmaterial>
        <language langcode="${collection.language}">${getLanguageName(collection.language)}</language>
      </langmaterial>
      <abstract>${escapeXml(collection.abstract)}</abstract>
    </did>

    <bioghist>
      <p>Această colecție conține documente oficiale ale Guvernului României, gestionate prin sistemul OpenArchive în conformitate cu standardele arhivistice naționale și internaționale.</p>
    </bioghist>

    <scopecontent>
      <p>${escapeXml(collection.description)}</p>
    </scopecontent>

    ${collection.accessRestrictions ? `<accessrestrict><p>${escapeXml(collection.accessRestrictions)}</p></accessrestrict>` : ''}
    
    ${collection.useRestrictions ? `<userestrict><p>${escapeXml(collection.useRestrictions)}</p></userestrict>` : ''}

    <dsc type="combined">
      <head>Inventarul documentelor</head>
      ${collection.documents.map(doc => generateDocumentEntry(doc)).join('\n')}
    </dsc>
  </archdesc>
</ead>`

  return formatXml(xml)
}

/**
 * Generate a document entry for collection inventory
 */
function generateDocumentEntry(document: EADDocument): string {
  return `      <c01 level="item">
        <did>
          <unittitle>${escapeXml(document.title)}</unittitle>
          <unitid>${escapeXml(document.id)}</unitid>
          ${document.date ? `<unitdate>${escapeXml(document.date)}</unitdate>` : ''}
          ${document.extent ? `<physdesc><extent>${escapeXml(document.extent)}</extent></physdesc>` : ''}
        </did>
        ${document.description ? `<scopecontent><p>${escapeXml(document.description)}</p></scopecontent>` : ''}
        ${generateDigitalObjectsSection(document.files)}
      </c01>`
}

/**
 * Generate subjects section
 */
function generateSubjectSection(subjects?: string[]): string {
  if (!subjects || subjects.length === 0) return ''
  
  return `<controlaccess>
      <head>Subjects</head>
      ${subjects.map(subject => `<subject>${escapeXml(subject)}</subject>`).join('\n      ')}
    </controlaccess>`
}

/**
 * Generate digital objects section
 */
function generateDigitalObjectsSection(files?: EADFile[]): string {
  if (!files || files.length === 0) return ''
  
  return `<daogrp>
      <head>Digital Objects</head>
      ${files.map(file => `
      <daoloc role="reference" title="${escapeXml(file.title)}" 
             ${file.href ? `href="${escapeXml(file.href)}"` : ''}>
        <daodesc>
          <p>Format: ${escapeXml(file.format)}</p>
          <p>Size: ${escapeXml(file.size)}</p>
          ${file.checksum ? `<p>Checksum: ${escapeXml(file.checksum)}</p>` : ''}
        </daodesc>
      </daoloc>`).join('')}
    </daogrp>`
}

/**
 * Generate MODS (Metadata Object Description Schema) XML
 */
export function generateMODS(document: EADDocument): string {
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<mods xmlns="http://www.loc.gov/mods/v3" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-7.xsd"
      version="3.7">
  
  <titleInfo>
    <title>${escapeXml(document.title)}</title>
  </titleInfo>
  
  ${document.creator ? `<name type="personal">
    <namePart>${escapeXml(document.creator)}</namePart>
    <role>
      <roleTerm type="text">creator</roleTerm>
    </role>
  </name>` : ''}
  
  <typeOfResource>text</typeOfResource>
  
  <genre authority="local">government document</genre>
  
  ${document.date ? `<originInfo>
    <dateCreated>${escapeXml(document.date)}</dateCreated>
  </originInfo>` : ''}
  
  ${document.language ? `<language>
    <languageTerm type="code" authority="iso639-2b">${document.language}</languageTerm>
  </language>` : ''}
  
  ${document.description ? `<abstract>${escapeXml(document.description)}</abstract>` : ''}
  
  ${document.subjects && document.subjects.length > 0 ? document.subjects.map(subject => 
    `<subject>
      <topic>${escapeXml(subject)}</topic>
    </subject>`
  ).join('\n  ') : ''}
  
  <identifier type="local">${escapeXml(document.id)}</identifier>
  
  ${document.repository ? `<location>
    <physicalLocation>${escapeXml(document.repository)}</physicalLocation>
  </location>` : ''}
  
  ${document.accessRestrictions ? `<accessCondition type="restriction on access">${escapeXml(document.accessRestrictions)}</accessCondition>` : ''}
  
  ${document.useRestrictions ? `<accessCondition type="use and reproduction">${escapeXml(document.useRestrictions)}</accessCondition>` : ''}
  
  <recordInfo>
    <recordCreationDate encoding="w3cdtf">${new Date().toISOString()}</recordCreationDate>
    <recordOrigin>Generated by OpenArchive System</recordOrigin>
  </recordInfo>
</mods>`

  return formatXml(xml)
}

/**
 * Generate Dublin Core XML
 */
export function generateDublinCore(document: EADDocument): string {
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<dc xmlns="http://purl.org/dc/elements/1.1/"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://purl.org/dc/elements/1.1/ http://dublincore.org/schemas/xmls/qdc/2008/02/11/dc.xsd">
  
  <title>${escapeXml(document.title)}</title>
  
  ${document.creator ? `<creator>${escapeXml(document.creator)}</creator>` : ''}
  
  ${document.description ? `<description>${escapeXml(document.description)}</description>` : ''}
  
  ${document.date ? `<date>${escapeXml(document.date)}</date>` : ''}
  
  <type>Text</type>
  <type>Government Document</type>
  
  ${document.language ? `<language>${document.language}</language>` : ''}
  
  <identifier>${escapeXml(document.id)}</identifier>
  
  ${document.repository ? `<publisher>${escapeXml(document.repository)}</publisher>` : ''}
  
  ${document.subjects && document.subjects.length > 0 ? document.subjects.map(subject => 
    `<subject>${escapeXml(subject)}</subject>`
  ).join('\n  ') : ''}
  
  ${document.accessRestrictions ? `<rights>${escapeXml(document.accessRestrictions)}</rights>` : ''}
</dc>`

  return formatXml(xml)
}

/**
 * Escape XML special characters
 */
function escapeXml(text: string): string {
  if (!text) return ''
  
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
}

/**
 * Get language name from code
 */
function getLanguageName(code: string): string {
  const languages: Record<string, string> = {
    'rum': 'Romanian',
    'ro': 'Romanian',
    'eng': 'English',
    'en': 'English',
    'fre': 'French',
    'fr': 'French',
    'ger': 'German',
    'de': 'German'
  }
  
  return languages[code] || 'Unknown'
}

/**
 * Basic XML formatting
 */
function formatXml(xml: string): string {
  // Simple indentation for readability
  let formatted = xml
  let indent = 0
  const tab = '  '
  
  formatted = formatted.replace(/>\s*</g, '>\n<')
  
  const lines = formatted.split('\n')
  const formattedLines: string[] = []
  
  for (const line of lines) {
    const trimmed = line.trim()
    if (trimmed.length === 0) continue
    
    if (trimmed.startsWith('</')) {
      indent = Math.max(0, indent - 1)
    }
    
    formattedLines.push(tab.repeat(indent) + trimmed)
    
    if (trimmed.startsWith('<') && !trimmed.startsWith('</') && !trimmed.endsWith('/>') && !trimmed.includes('</')){
      indent++
    }
  }
  
  return formattedLines.join('\n')
}

/**
 * Validate EAD XML structure
 */
export function validateEAD(xml: string): {
  isValid: boolean
  errors: string[]
  warnings: string[]
} {
  const errors: string[] = []
  const warnings: string[] = []
  
  // Basic validation checks
  if (!xml.includes('<?xml')) {
    errors.push('Missing XML declaration')
  }
  
  if (!xml.includes('<ead')) {
    errors.push('Missing EAD root element')
  }
  
  if (!xml.includes('<eadheader>')) {
    errors.push('Missing EAD header')
  }
  
  if (!xml.includes('<archdesc')) {
    errors.push('Missing archival description')
  }
  
  // Check for required elements
  if (!xml.includes('<unittitle>')) {
    errors.push('Missing unit title')
  }
  
  if (!xml.includes('<unitid>')) {
    errors.push('Missing unit identifier')
  }
  
  // XML structure validation
  const openTags = xml.match(/<[^\/][^>]*>/g) || []
  const closeTags = xml.match(/<\/[^>]*>/g) || []
  
  if (openTags.length !== closeTags.length) {
    warnings.push('Unbalanced XML tags detected')
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  }
}

/**
 * Convert document metadata to EAD format
 */
export function documentToEAD(document: {
  id: string
  title: string
  description?: string
  creator_info?: any
  creation_date?: string
  document_type?: string
  retention_category?: string
}): EADDocument {
  return {
    id: document.id,
    title: document.title,
    description: document.description,
    creator: document.creator_info?.name || 'Unknown',
    date: document.creation_date,
    language: 'rum',
    repository: 'Arhivele Naționale ale României',
    extent: document.document_type || 'Digital document',
    accessRestrictions: document.retention_category === 'permanent' ? 
      'Acces public după expirarea perioadei de confidențialitate' : 
      'Acces restricționat conform legislației în vigoare',
    useRestrictions: 'Reproducerea doar cu acordul instituției'
  }
} 